我们通常数值类型的数据是存储在栈中的而引用类型的数据是存储在堆中的,这个说法正确但不完全正确.
1. 堆它通常存储引用类型的数据,当我们存储引用类型的数据它的具体数据会放在堆中,值类型如果他是局部变量他的地址会放到栈中存储.如果它是成员变量的话,它的数据会放到堆中存储因为类本身也是存储在堆中的,数据存放到类的实例中.如果类内存储其他的引用类型,那么类内存储的就算引用,引用指向堆中的另一块区域
2. 栈通常存储的是我们的值类型数据和引用类型的引用.但如果值是一个成员变量的话它的数据也会存储到堆中,因为类也在堆中存储. 在C#中，栈（Stack）是一种特殊的集合，它遵循“先进后出”（LIFO）原则。栈主要用于存储一些临时变量，支持从栈顶获取元素（即取出最后一个元素），也支持删除元素（即弹出元素）。当我们调试时调用堆栈就是从上面的一层一层一层的向下找看看是谁调用了我.
3. 在C#中，静态变量（如static关键字声明的变量）存储在CLR (Common Language Runtime)的静态内存中，而非堆或栈[5](https://zhuanlan.zhihu.com/p/665108249?utm_id=0)。它们的生命周期与程序的生命周期相同，当程序开始时，它们被初始化，当程序终止时，它们被销毁[5](https://zhuanlan.zhihu.com/p/665108249?utm_id=0)。

静态变量存储在托管堆（Managed Heap）上的高频段，而不是与对象实例一起存储[5](https://zhuanlan.zhihu.com/p/665108249?utm_id=0)。所有实例共享同一个 static 变量[5](https://zhuanlan.zhihu.com/p/665108249?utm_id=0)。

静态变量的存储位置也是实现细节，开发者不需要担心。然而，C#规范确保了变量存储在适当的类型中[7](https://social.msdn.microsoft.com/Forums/vstudio/en-US/93d6a2fe-6bd6-4790-9f3e-e552468ccf4e/where-exactly-the-static-variables-will-be-stored?forum=netfxbcl)。

值得注意的是，有些特殊的静态变量，如被ThreadStatic标记的静态变量，存储在特定的线程本地存储区域，而非CLR的静态内存中[4](https://blog.51cto.com/u_15127622/2882826)。这种设计允许线程安全地访问这些变量，而无需担心线程冲突。
静态类型的特性是因为静态类型的数据存储在静态存储区域中,静态存储区的开辟时间是RunTime 之前,而栈和堆是RunTime


#为什么结构体类型的数组访问起来比类类型的数组快
当CPU读取内存中的一个地址时，它通常会读取该地址周围的一块数据，而不仅仅是特定地址上存储的数据。
在访问结构体数组时比访问类数组快的一个主要原因是内存布局和访问模式的差异。

当你创建一个结构体数组时，数组的每个元素都直接存储在内存中，它们在内存中是连续存储的。这意味着你可以通过索引直接计算出元素的内存地址，并且访问操作是相对简单和高效的。

另一方面，当你创建一个类数组时，数组的元素实际上是对象的引用。每个引用存储在数组中，而对象本身则存储在堆上的其他内存位置。因此，访问类数组时，你首先需要通过索引获取引用，然后再使用引用来访问实际的对象。这涉及了额外的间接寻址操作，会导致访问速度相对较慢。

此外，在结构体数组中，由于元素是连续存储的，这有利于缓存的有效利用。现代计算机系统中，缓存是一个重要的性能优化因素。连续的内存访问可以更好地利用缓存行，从而提高访问效率。而类数组的元素分散在堆的不同位置，可能不利于缓存的有效利用，导致访问速度较慢。

总之，结构体数组在访问时相对较快，因为它们的元素直接存储在连续的内存位置上，并且没有额外的引用解引用操作。而类数组需要通过引用来访问对象，这涉及了额外的间接寻址操作，并且可能不利于缓存的有效利用，导致访问速度较慢。

总结因为数组在堆中开辟的空间是有序的,所以当我们访问值类型的数组时可以直接拿到数据<font color=red>当CPU读取内存中的一个地址时，它通常会读取该地址周围的一块数据，而不仅仅是特定地址上存储的数据这样会更快</font>,而访问引用类型时还需要根据数组中的地址进行二次查找.