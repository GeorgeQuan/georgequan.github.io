#渲染

对于大多数现代图形 API，如 DirectX 11/12 和 OpenGL 4.x，一次绘制调用的顶点数量上限通常为 65535 个。这是因为这些图形 API 使用 16 位索引来引用顶点数据，而 16 位索引的最大值是 65535。

在 Unity 中，每个模型
的渲染通常会生成一个绘制调用（Draw Call）。绘制调用是指将一个或多个图形对象提交给图形 API（如 DirectX 或 OpenGL）进行渲染的操作。
Draw Call是CPU 向GPU 发送的渲染指令

每个绘制调用包含一系列需要渲染的顶点和对应的渲染状态（如材质、着色器等）。当你在场景中有多个独立的模型时，每个模型通常会生成一个单独的绘制调用。

这意味着，如果你有多个独立的模型需要渲染，每个模型都会产生一个 draw call。过多的 draw call 可能会对性能产生负面影响，因为渲染线程需要在每个 draw call 之间进行切换和处理。

为了优化性能，减少 draw call 的数量是一种常见的优化策略。你可以通过使用批处理（Batching）技术，将多个相同材质和渲染状态的模型合并到一个 draw call 中。这样可以减少绘制调用的数量，提高渲染性能。

Unity 提供了静态批处理（Static Batching）和动态批处理（Dynamic Batching）等功能，用于自动合并可以批处理的模型。此外，还可以使用 GPU 实例化（GPU Instancing）来在一个 draw call 中渲染多个相同模型的实例。

综上所述，尽量减少 draw call 的数量对于提高游戏的性能和渲染效率是非常重要的。

合并的前提,他们的材质和网格都相同
总的来讲就是每次渲染最多可以渲染65535个顶点,但每一次渲染无论顶点多少他们的开销都是一样的,所有我们争取减少他们的渲染次数从而实现优化.每次渲染的时候Cpu会让Gpu来做这个事情但Gpu能做的事情是有次序的,这就意味着Cpu需要等Gpu处理完一次渲染后,才能进行下一次渲染.这很消耗性能

#静态批处理
在 Unity 中，静态批处理（Static Batching）是一种自动优化技术，用于合并多个静态物体的渲染调用，以减少绘制调用的数量，从而提高渲染性能。

静态批处理适用于不需要移动或改变的静态物体，例如场景中的静态环境模型、地形等。当多个静态物体具有相同的材质和渲染状态时，Unity 在运行时会自动将它们合并为一个绘制调用，以减少绘制调用的数量。

要启用静态批处理，需要满足以下条件：

1. 相同材质：多个物体使用相同的材质（Material）。材质定义了物体的着色、纹理和其他渲染属性。
    
2. 相同渲染状态：多个物体具有相同的渲染状态，例如渲染队列、深度测试、剔除模式等。
    
3. 静态物体：物体不需要移动或改变。静态物体可以是场景中的静态环境模型、地形等，或者是已经合并为静态的动态物体。
    

当以上条件满足时，Unity 在构建阶段会自动执行静态批处理，将满足条件的静态物体合并为一个或多个绘制调用。这样可以减少绘制调用的数量，降低渲染开销。

需要注意的是，静态批处理并不适用于所有情况。例如，具有复杂的动画或变形的物体无法进行静态批处理。此外，静态批处理也可能会增加内存消耗，因为合并后的物体可能需要更多的顶点和纹理内存。

在 Unity 中，你无需手动编写代码来启用静态批处理，只需满足条件并在构建阶段进行合理的设置，Unity 会自动执行静态批处理优化。你可以通过 Unity 编辑器的统计信息面板（Stats）来查看批处理的效果和绘制调用的数量，以便进行优化和调试。
![[Pasted image 20240301134323.png]]
这个选项勾选后unity 就会对它进行静态批处理了
#ComBine用法合并mesh
CombineInstance 是 Unity 中用于合并多个 Mesh 的结构体。它允许你将多个 Mesh 数据合并到一个 Mesh 中，以减少绘制调用的数量，提高渲染性能。

以下是 CombineInstance 的用法示例：

csharp

复制

```
// 创建 CombineInstance 数组
CombineInstance[] combines = new CombineInstance[2];

// 设置第一个 CombineInstance
combines[0].mesh = mesh1;
combines[0].transform = transform1.localToWorldMatrix;

// 设置第二个 CombineInstance
combines[1].mesh = mesh2;
combines[1].transform = transform2.localToWorldMatrix;

// 创建新的合并后的 Mesh
Mesh mergedMesh = new Mesh();
mergedMesh.CombineMeshes(combines);

// 使用合并后的 Mesh 进行渲染等操作
```

在上述示例中，我们创建了一个 `CombineInstance` 数组 `combines`，并设置了两个 `CombineInstance` 对象。

对于每个 `CombineInstance`，我们需要设置以下两个属性：

1. `mesh`：要合并的 Mesh 对象。在示例中，`mesh1` 和 `mesh2` 分别表示两个要合并的 Mesh。
    
2. `transform`：要应用于 Mesh 的变换矩阵。我们使用 `transform.localToWorldMatrix` 将 `Transform` 组件的本地坐标系转换为世界坐标系，并将其赋值给 `CombineInstance` 的变换矩阵。
    

接下来，我们创建一个新的空 Mesh 对象 `mergedMesh`，用于存储合并后的 Mesh 数据。

最后，我们调用 `CombineMeshes` 方法将 `combines` 数组中的 Mesh 数据合并到 `mergedMesh` 中。这将生成一个包含所有合并网格数据的新 Mesh。

你可以根据需要对 `mergedMesh` 进行后续的操作，比如渲染、碰撞检测等。

需要注意的是，合并后的 Mesh 可能会增加内存占用，因为它包含了所有合并的 Mesh 的数据。因此，在使用 CombineInstance 进行合并时，你应该在权衡性能和内存占用方面进行评估，并确保合并后的 Mesh 符合你的需求。



#图片读取优化
1. IO操作
在计算机科学中，"IO" 是指输入/输出（Input/Output）。图片的IO操作是指对图片数据进行读取和写入的操作。

图片的IO操作通常包括以下几个方面：

1. 图片读取（Input）：将图片数据从外部存储介质（如硬盘、网络等）加载到计算机内存中。这通常涉及从文件系统中读取图片文件，并将其解析为计算机可以理解的数据格式，如位图（Bitmap）、压缩纹理（Compressed Texture）等。
    
2. 图片写入（Output）：将计算机内存中的图片数据保存到外部存储介质中。这通常涉及将图片数据转换为适当的文件格式，并将其写入文件系统中，以便后续的读取和使用。
    
3. 图像编解码（Encoding/Decoding）：在图片的IO操作中，图片数据通常需要进行编码和解码。编码是将图片数据转换为特定格式的过程，以便在存储或传输时占用更少的空间或带宽。解码是将编码的图片数据还原为原始数据的过程，以便进行渲染、编辑等操作。
    
4. 图片格式转换（Format Conversion）：在图片的IO操作中，有时需要将图片数据从一种格式转换为另一种格式，以满足特定的需求。例如，将一个图片文件保存为不同的压缩格式、将一个位图转换为矢量图等。
    

具体的图片IO操作的实现方式和细节取决于使用的编程语言和库。常用的编程语言（如C++, C#, Python）和图形处理库（如OpenCV、PIL/Pillow、Unity的Texture2D等）提供了相应的API和函数，用于进行图片的IO操作
2.  句柄
IO操作通常会生成句柄（Handle）或文件描述符（File Descriptor），用于标识和操作打开的文件或设备。

在许多操作系统中，包括Windows、Linux和macOS，文件和设备都被视为文件对象。当进行IO操作时，操作系统会为每个打开的文件或设备分配一个唯一的句柄或文件描述符。这个句柄或文件描述符可以被用于后续的IO操作，如读取、写入、关闭文件等。

句柄或文件描述符通常是整数值，可以用作对文件或设备的引用。通过句柄或文件描述符，操作系统可以跟踪文件的状态、位置和其他相关信息。

在编程中，使用适当的API或库函数打开文件或设备时，通常会返回一个句柄或文件描述符。后续的IO操作可以使用该句柄或文件描述符来读取或写入文件数据。

需要注意的是，不同的操作系统和编程语言可能具有不同的句柄或文件描述符的概念和实现方式。因此，在进行IO操作时，具体的句柄或文件描述符的使用方法和功能可能会有所差异。

总结:我们通常会用图集来存储大部分的图片,因为每个图片都会有一个io操作并且生成文件句柄. 如果我们只用图集来存储图片的话,那么这种操作只会执行一次.