# 物体移动常用的7种方法


1. Translate  是TransFrom 种自带的一个移动方法 他接收一个向量作为参数朝这个方向一直移动
2. Lerp插值  他是v3类型的一个静态方法 他接收三个参数 分别是起始位置,终点,每次增加剩余距离的百分比,如果直接给百分比的话,那么物体移动的速度会由快到慢,因为物体距离终点的距离在不断缩短,我们用一个v3类型来接收 1/(当前位置-终点).magnitude . 1/任何数得到他的负数,当前位置减去终点得到的是终点到当前位置的向量.用模长来算出距离乘以一个较小的数方便观察.(0.0001f) 但是要注意如果我们是用lerp移动的话因为他是插值移动所以只能无限接近终点而不会到达.如果想到达的话可以加一个判断距离小于多少就给他终点的位置.![[./_resources/物体移动常用的7种方法.resources/unknown_filename.png]]这样写确实可以正确检测到物体达到目标点,那是因为浮点数小数点过后的位数太多了已经无法显示了f\*0.01的结构会变成整数0 这样物体就会停止移动.检测到的结果也会因为小数点位数过多显示成整数.
3.   Vector3.SmoothDamp(平滑阻尼) 这个函数可以让物体在起点和终点之间平滑移动,它提供了四个参数的重载,当前位置 终点 移动速度 所需时间
   ![[./_resources/物体移动常用的7种方法.resources/unknown_filename.1.png]]第三个参数我们不需要给他赋值因为ref所以允许从方法内给这个变量赋值,它会自动根据当前位置,终点和时间来更改速.它同样也具备多个参数的重载
    ![[./_resources/物体移动常用的7种方法.resources/unknown_filename.2.png|423x0]]
    它大多被用来平滑移动摄像机.在unity中SmoothDamp的阻尼的值是1(临界阻尼)所以我们观测不到阻尼震动
4.在接下来的方法中我们会用到刚体,首先我们为物体添加刚体并且在代码中获取它
  刚体方法1.改变刚体速度 
    刚体组件.velocity=new V3();
    通过给刚体组件添加速度来实现一个移动的效果
    rigidbody.velocity = new Vector3(1f, 0f, 0f);
    给刚体的x轴添加一个数这样刚体会向x轴的正数方向移动,如果你想向相反的方向移动的话就把它改成负数
    需要修改垂直和前进的话就对y和z 轴进行修改,由于是直接修改速度所以会平滑移动
    需要注意的是，刚体的移动是受到物理引擎的模拟和碰撞检测的影响的。如果在场景中存在其他刚体或碰撞器（Collider），刚体的运动可能会受到碰撞力、摩擦力等物理效应的影响。如果需要更精细的控制刚体的移动，可以使用`刚体.AddForce()`或`刚体.AddTorque()`等方法来施加力或扭矩。
5.给刚体添加一个力从而达到移动的效果
  刚体.AddForce 方法添加力给刚体
  它接收一个v3类型的参数
  ```c#
// 施加向上的力
rigidbody.AddForce(new Vector3(0f, 10f, 0f));
，向量 `(0f, 10f, 0f)` 表示向上的力，其中 `10f` 是力的大小。正值表示朝向对应轴正方向的力，负值表示朝向对应轴负方向的力。
```
当我们不考虑空气阻力,摩擦力等因素时,刚体在移动时不会有动能的消耗,那么他就会以一个速度一直运动达到平滑移动的效果.
如果我们把它写在Update里面这意味着刚体会在每一帧都被添加一个力,这样刚体的速度就会越来越快
当我们在用刚体移动时很少会不考虑到空气阻力和摩擦力等影响,下面是常见的几种影响刚体移动的行为
1. 碰撞：当刚体与其他物体碰撞时，碰撞力会改变刚体的运动状态，可能导致停止或改变移动方向。
    
2. 摩擦力：刚体在与表面接触时会受到摩擦力的作用。摩擦力可以逐渐减慢刚体的速度，直到最终停止。
    
3. 空气阻力：虽然在问题描述中忽略了空气阻力，但在实际世界中，空气阻力会对物体的运动产生影响。空气阻力会逐渐减慢刚体的速度，导致最终停止。
    
4. 外部力的改变：如果在运动过程中施加其他力或改变施加力的方向，刚体的运动将受到影响，可能导致停止或改变移动方向。
    
5. 能量损失：在物体的运动过程中，可能会发生能量损失，例如能量转化为其他形式的能量（例如热能）。这些能量损失会逐渐减慢刚体的速度，导致最终停止。
    能量损失通常是由摩擦力产生的,刚体移动的动力会通过摩擦力转换成热能,动力就会慢慢流失直到停止
6.刚体.Moveposition(v3);
他会直接修改物体的位置到指定位置,如果你想让物体持续的向一个方向移动的话可以这样写
```c#
 ri.MovePosition(transform.position+Vector3.right*Time.deltaTime);
 这样移动起来效果并不流畅能检测到一点点卡顿,可以是因为他是每一帧改变物体位置吧
 如果你没用*Time.deltaTime的话建议写在FixedUpdate 中 
 在常规情况下，`FixedUpdate` 函数的调用频率是每秒固定的次数。默认情况下，Unity 的固定时间步长（Fixed Timestep）设置为 0.02 秒（即每秒 50 次调用），这是一个常用的默认值。
```
7.CharacterController (角色控制器移动)
CharacterController.Move();
他只有一个参数就是每一帧移动的距离
