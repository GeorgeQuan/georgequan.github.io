# 强转 (显性转换}


强转 (显性转换}
多态的前提
1 父类new子类
2 多态一定在继承的条件下
3 必须要有重写
![[./_resources/强转_(显性转换}.resources/unknown_filename.png]]
我们知道拆箱和装箱是很消耗资源的一个操作,那为什么它会消耗资源呢.拆装箱设计到值类型和引用类型的类型转换,而这又会涉及到栈中的数据和堆中的数据的移除和复制,所以它很消耗资源
![[./_resources/强转_(显性转换}.resources/unknown_filename.1.png]]
 **![[./_resources/强转_(显性转换}.resources/unknown_filename.2.png]]  静态类中的变量也得是静态类,因为加载的时间不同;**
**局部变量必须有默认值**
**成员变量有默认值(类内 方法外)**
**结构体不能继承类,只能继承接口**
**类型是方法没有位置,需要定义字段才能储存**
**![[./_resources/强转_(显性转换}.resources/unknown_filename.3.png]]**
**string 没有无参构造** 
**![[./_resources/强转_(显性转换}.resources/unknown_filename.4.png]]**
**自动属性,自动定义隐藏的字段存储和输出**
**当接口做行参的时候,实参是实现过该接口的子类对象 !!!**
**foreach的底层如下 接口为**
**![[./_resources/强转_(显性转换}.resources/unknown_filename.5.png]]**

#装箱和拆箱
1. [装箱]（Boxing）是将值类型转换为引用类型的过程。在C#中，装箱是隐式的转换过程，它允许值类型变量被视为对象类型（即引用类型）。装箱发生在将值类型变量赋值给引用类型变量时，例如将一个`int`赋值给一个`object`变量。这个过程中，值类型变量的值会被复制到堆内存中，并且这个值类型变量会被封装在一个新的对象中，这个对象就是引用类型变量所指向的对象。

装箱的底层实现涉及到以下几个步骤：

1. **创建对象**：首先，运行时会在堆内存中为新的对象分配空间。

2. **复制值**：然后，值类型变量的值会被复制到这个新创建的对象中。

3. **设置引用**：最后，引用类型变量会被设置为指向这个新创建的对象。

这个过程允许值类型变量被视为对象类型，从而能够在需要时进行类型转换和操作。装箱的主要用途是为了能够将值类型变量作为参数传递给需要接受对象类型参数的方法，或者将值类型变量存储在集合中，这些集合是泛型的并且接受对象类型作为元素类型。
2. [拆箱] 在C#中，当引用类型转换成值类型时，底层实现涉及到运行时类型检查和值类型的复制。这个过程通常被称为“拆箱”。虽然具体的实现细节可能会随着.NET版本的更新而变化，但基本的拆箱过程可以概括为以下几个步骤：

1. **检查是否为null**：首先，运行时会检查要拆箱的引用是否为null。如果是null，那么会抛出`InvalidOperationException`异常，因为无法从null引用中获取值。

2. **运行时类型检查**：如果引用不是null，运行时会检查该引用指向的对象的类型是否与目标值类型匹配。如果类型不匹配，会抛出`InvalidCastException`异常。

3. **值类型的复制**：如果类型检查成功，运行时会创建一个新的值类型实例，并将原始值复制到新实例中。这个过程涉及到值类型的复制，而不是引用类型的复制。

4. **返回新值类型实例**：最后，运行时会返回新创建的值类型实例，这个实例包含了原始值的副本。

这个过程的关键在于，它允许开发者在需要时将引用类型转换回其原始值类型，从而访问和操作这些值类型的值。值类型的复制是必要的，因为值类型的变量存储的是值，而不是引用。因此，拆箱操作需要创建一个新的值类型实例，并将原始值复制到这个新实例中。

虽然拆箱操作提供了灵活性，但也需要开发者注意类型安全和异常处理。因为如果类型不匹配，拆箱操作会抛出异常，可能导致程序崩溃。因此，在进行拆箱操作时，应该确保引用指向的对象的类型与目标值类型匹配，或者使用类型转换来明确指定目标类型。