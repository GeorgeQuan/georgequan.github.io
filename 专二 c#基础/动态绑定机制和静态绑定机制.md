oop 面向对象的程序设计（Object Oriented Programming）中重要的概念多态
```c#

abstract class Animal
{
    public abstract void MakeSound();
}

class Dog : Animal
{
    public override void MakeSound()
    {
        Console.WriteLine("Woof!");
    }
	public void Miao()
    {
	  print("喵喵叫")
	}
}

class Cat : Animal
{
    public override void MakeSound()
    {
        Console.WriteLine("Meow!");
    }
}

class Program
{
    static void Main(string[] args)
    {
        Animal dog = new Dog();
	    //这里的Animal是静态类型,就是你在编译前确定的类型,Dog则是动态类型在编译时确定的类型
	    //那么变量dog 的静态类型就是Animal而动态类型是Dog.
	    //那么静态类型和动态类型有什么用呢,
	    //动态绑定指的是:方法调用是在运行时根据对象的真实类型来定位和执行方法,而不是在编译时确定的。虚方法调用依靠对象的运行时类型,而非编译时类型,所以在这个案例中调用的会是子类修改过的虚方法,
	    //而非虚方法,就会依靠非编译时的类型进行方法查找
        Animal cat = new Cat();

        dog.MakeSound(); // 输出: Woof!
        cat.MakeSound(); // 输出: Meow!
        dog.Miao();//会报错因为静态类型中没有此方法
		
    }
}

```
#静态类型与动态类型
### 1、何谓动态类型

C#是一门静态类型语言。编译器知道代码中表达式的类型，知道任何类型中可用的成员。它应用了相当复杂的规则来决定哪个成员应该在何时使用。这包括了重载决策；在（动态类型出现）之前的唯一途径是根据对象在执行时的类型，来选择虚方法的实现。决定使用哪个成员的过程称为绑定（binding），对于静态类型的语言来说，绑定发生在编译时。而在动态类型的语言中，所有的绑定都发生在执行时。编译器或解析器可以检查语法是否正确，但却无法检查所调用的方法或所访问的属性是否真的存在。

值得一提的是，C# 4全新的动态特性不包含在执行时解释C#源代码的功能。当然，有时候，无论采取什么方式，都能完成同样的工作。由于让编译器在执行前进行了更多的准备工作，因此静态系统的性能往往比动态系统更优。
### 2、动态类型什么时候有用，为什么

动态类型立足于两个有利要点：

①通常我们需要知道调用的成员名称、要传入的参数以及要调用的对象，但C#编译器通常需要得更多。至关重要的是，为了准确地确定成员（模型重载），我们需要知道所调用的对象的类型和参数的类型。我们有时无法在编译时知道这些类型，即使你确实能保证代码运行时成员会存在并且正确。

②动态类型的第二个重要的特性是，对象可以通过分析提供给它的名称和参数来响应某个调用。其行为就像是该类型正常地声明了成员一样，即使直到执行时我们才能知道成员的名称。

使用动态语言进行编程还有一个特性，它往往是使用适当解释器进行编程的实验性风格。这一点并非与C# 4直接相关，但C# 4可以与运行在DLR（Dynamic Language Runtime，动态语言运行时）上的动态语言进行丰富的互操作，这意味着如果你要处理的问题可以从这种风格中受益，你就可以直接使用C#返回的结果，而不用后来再将其移植到C#中。
### 3、C# 4如何提供动态类型

C# 4引入了一个新的类型，称为dynamic。编译器对待该类型的方式与普通的CLR类型不同。任何使用了动态值的表达式都会从根本上改变编译器的行为。编译器不会试图弄懂代码的确切含义，不会恰当地绑定各个成员的访问，不会执行重载决策。它只是通过解析源代码，找出要执行的操作的种类、名称、所涉及的参数以及其他相关信息。编译器也不会发出（emit）IL来直接执行代码，而是使用所有必要的信息生成调用DLR的代码。剩下的工作将在执行时进行。

当DLR在执行时绑定相关调用时，确定应该发生什么事情的过程非常复杂。在此期间，不仅仅要考虑方法重载等常规的C#规则，而且该对象本身也需要动态确定。
