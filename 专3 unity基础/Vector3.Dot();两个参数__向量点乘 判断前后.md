# Vector3.Dot();两个参数//向量点乘 判断前后


Vector3.Dot();两个参数//向量点乘 判断前后
1 玩家的面朝向
2 向量( 敌人的位置减去玩家的位置)

* 点乘>0,两个向量方向基本一致 前面
* 点乘=0,两个向量互相垂直
* 点乘<0,两个向量方向相反 后面
![[Pasted image 20231227162622.png]]
我们把y的正数方向比作玩家的正方向,而负数比作玩家的反方向,当点乘的结果大于0的时候以为着敌人处于正数y的区域那么敌人就在玩家的前面,当结果等于0时,意味着敌人与玩家处于同一水平线
我们现在拥有玩家的正方向v3(0,0,1)和玩家到敌人的向量v3(1,0,1)

我们将所有分量乘积相加:
- X分量: 0 * 1 = 0
- Y分量: 0 * 0 = 0
- Z分量: 1 * 1 = 1
  在把结果相加就得出了点乘的结果
  0+0+1=1
  结果为大于0 的数意味着敌人的玩家的前面
  向量a点乘向量b ,就等于向量a 在向量b上的投影乘向量b的模长
  点乘可以求前后,和投影(用点乘结果反推)
  a点乘b 和b点乘a 的结果是一样的
	点乘的计算公式 向量a的模长 * 向量b的模长*cos(α°)
	那如果我们想求α° 我们用点乘的结果/(向量a的模长 * 向量b的模长) 这样就求出了cos 的值,
	再使用反三角函数Mathf.Acos() 就能求出角度了(计算角度可以应用于扇形检测,扇形检测就是距离判断+角度判断)

vector3.cross();//向量差乘 判断左右 返回一个Vectra3 类型的坐标
  叉乘的结果向量的模长等于原始两个向量所张成的平行四边形的面积。叉乘是求法线的

1 玩家的面朝向
2 向量( 敌人的位置减去玩家的位置)

* 差乘.y>0,两个向量方向基本一致 右方
* 差乘y=0,两个向量互相垂直
* 差乘.y<0,两个向量方向相反 左方

Vector3.Angle 用与计算两个三维向量之间的角度 返回一个角度float类型的值 参数是两个物体的位置vector3 类型
参数1 移动者减去非移动者得到向量,参数2 非移动者的面朝向

* ![[./_resources/Vector3.Dot();两个参数__向量点乘_判断前后.resources/unknown_filename.png]]

 Vector3.Distance() 里面有两个参数 分别是两个位置可以颠倒
返回一个float(两个位置之间的距离)
向量的模长就是两个位置之间的距离 和vector3.distance 是一样的 
如果想获取玩家的向量用敌人的位置减玩家在.maginitude(模) 一样可以获取到距离 同样会返回一个浮点型的值
模长为1的向量就叫单位向量,以下是单位向量
![[./_resources/Vector3.Dot();两个参数__向量点乘_判断前后.resources/unknown_filename.1.png]]
向量归一化 用向量来.normalized 这样这个向量的模长就bian成了1
![[./_resources/Vector3.Dot();两个参数__向量点乘_判断前后.resources/unknown_filename.2.png]]
扇形子弹
![[./_resources/Vector3.Dot();两个参数__向量点乘_判断前后.resources/unknown_filename.3.png|447x0]]

