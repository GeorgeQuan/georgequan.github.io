#概述
在程序运行时,系统会分配栈空间,默认的栈空间大小是1MB.每个线程都拥有自己的栈空间.首先我们先来理解栈帧.
#栈帧
栈帧（Stack Frame），也称为活动记录（Activation Record）或帧（Frame），是在程序执行过程中用于支持函数调用和返回的一种数据结构。

栈帧是在函数调用时动态创建的，在函数执行过程中用于存储函数的局部变量、参数、返回地址和其他与函数执行相关的信息。每个函数调用都会创建一个新的栈帧，形成一个栈的层次结构。

栈帧通常包含以下几个重要的组成部分：

1. 返回地址（Return Address）：指示函数执行完毕后程序应该返回的位置，通常是调用函数的下一条指令地址。(这里存储的是当前执行的函数位置,用于继续执行下层栈帧的逻辑)
    
2. 参数（Arguments）：传递给函数的输入值，包括通过值传递、引用传递或者其他方式传递的参数。
    
3. 局部变量（Local Variables）：函数内部定义的变量，其作用域仅限于函数的执行过程中。
    
4. 中间结果和临时变量（Intermediate Results and Temporary Variables）：在函数执行过程中产生的中间计算结果和临时变量。
    
5. 其他与函数调用相关的信息：如异常处理信息、协程状态等。
    

栈帧的创建和销毁是由编程语言和编译器/解释器来管理的。当一个函数被调用时，当前函数的栈帧会被创建并推入调用栈（Call Stack）中。当函数执行完毕后，对应的栈帧会被销毁，栈指针回退到前一个栈帧，程序继续执行前一个函数或返回到主程序。

栈帧的使用和管理对于函数的参数传递、局部变量的存储和恢复、控制流的管理等都起着重要的作用。它提供了函数执行所需的上下文信息，并支持函数的嵌套调用和递归算法的执行。


#运行逻辑 
在我们的代码运行时就会开辟栈空间,栈的结构是一层一层的,每一层都是一个栈帧,
当在一个函数中执行到另一个函数时，栈中的情况如下：

1. 当前函数的栈帧：当前函数的栈帧包含了当前函数的局部变量、参数、返回地址和其他相关信息。这个栈帧位于栈的顶部。
    
2. 被调用函数的栈帧：在调用函数时，会为被调用函数创建一个新的栈帧，并将其推入栈的顶部。被调用函数的栈帧包含了被调用函数的局部变量、参数、返回地址和其他相关信息。
    
3. 返回地址：在当前函数的栈帧中，存在一个返回地址，指示当前函数执行完毕后应该返回的位置。这个返回地址会被保存在被调用函数的栈帧中，作为被调用函数执行完毕后的返回位置。继续执行下层栈帧的逻辑.
    
4. 栈的结构：栈是一种后进先出（Last-In-First-Out，LIFO）的数据结构。因此，当前函数的栈帧位于被调用函数的栈帧上方。每次函数调用都会创建一个新的栈帧，并将其推入栈的顶部。
    

当被调用函数执行完毕后，被调用函数的栈帧会被弹出栈，同时返回地址会被取出，控制流会返回到调用函数的位置。此时，栈的结构会回到调用函数的栈帧上方。

通过这种方式，栈中的栈帧会根据函数的调用和返回动态地变化，以支持函数嵌套调用和控制流的管理。
#栈的返回值
这是最有意思的一个点.在Lua 中栈的返回值会被存放栈顶,用于获取.但是在Unity 中不一样.
在unity 中函数的返回值会判断它是引用类型还是值类型
1. 值类型: 值类型的数据,会存储在CPU的寄存器中,在x64架构下，函数的返回值通常存储在`RAX`寄存器中（对于64位的返回值），或者在`EAX`寄存器中（对于32位的返回值）。这是因为在x64架构下，`RAX`和`EAX`寄存器被设计为存储函数的返回值。这种设计允许函数返回值在不需要额外的堆栈空间的情况下被传递给调用者，从而提高了性能[5](https://www.51cto.com/article/629172.html)。(这里的位指的是返回值的大小)

寄存器的使用是由编译器在编译生成CPU指令时决定的。如果编译器决定使用寄存器来传递参数或返回值，那么这些数据就会直接存储在寄存器中，而不是通过栈来传递。这是因为寄存器传参的好处是速度快，减少了对内存的读写次数[5](https://www.51cto.com/article/629172.html)。
总之，函数的返回值是存储在CPU内部的寄存器中的，而不是在CPU的栈中。这是为了确保函数返回值的快速传递和高效处理。
<font color=red>小型值类型的返回值可以直接存储在CPU寄存器中(如int,float)，而较大或复杂的值类型则通常通过栈上的临时变量来实现(如结构体)。</font>

2. 引用类型
在C#中，如果函数返回的是引用类型的值，那么这个引用实际上是指向存储在堆内存中的对象的指针。这种情况下，函数的返回值不是直接存储在寄存器中的，而是通过返回这个指针来实现。这个指针指向的对象在堆内存中存储，函数返回时，返回的是这个指针的值
如果返回值是引用类型,这意味着数据已经被存储到堆中了,就不需要存储在寄存器里面了.

我们在使用=接收返回值的时候就相当于,从CPU或者堆中拿返回值