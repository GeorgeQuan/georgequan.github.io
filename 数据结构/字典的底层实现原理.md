c# 字典的底层是用两个数组和散列函数实现的
其中两个数组分别是哈希桶和存储键值对数据的数组
散列函数是一种将键（Key）转换为哈希码（Hash Code）的函数。哈希码用于确定键在 `Dictionary<TKey, TValue>` 中的存储位置。C# 中的 `Dictionary<TKey, TValue>` 使用键的哈希码来计算桶的索引位置，并根据索引将键值对存储在相应的桶中。


这里只写了简单的实现逻辑.
首先Entry 结构体
```c#
private struct Entry
{
		public int hashCode;//哈希值
		public int next;//发生哈希冲突时,用于存储上一个Entry的下标
		public TKey key;//键
		public TValue value;//值
}

```
然后就算构成字典最重要的两个数组
```c#
private int[] buckets;//哈希桶
private Entry[] entries;//存储所有的结构体

```
当然还有更多的字段,我这里就不具体实现了,
![[Pasted image 20240508202810.png]]
#字典容器的扩容时机
	字典的底层数据结构主要包括哈希桶（hash buckets）和键值对数组（key-value array）。当字典中的元素数量逐渐增加时，为了保持性能的平衡，字典可能需要进行扩容。字典的扩容条件通常包括以下两个方面：
	
	1. 装载因子（Load Factor）：装载因子是指字典中已存储的键值对数量与哈希桶总数的比值。当装载因子超过一定阈值时，通常表示字典已经达到了负载的上限，可能会导致哈希冲突增加，影响性能。这时就需要进行扩容，以保持较低的装载因子。
	    
	     
	    
	    典型的装载因子阈值为 0.7，即当装载因子超过 0.7 时，就会触发扩容操作。当字典中的元素数量超过哈希桶数量的 0.7 倍时，就会进行扩容。
	    
	2. 冲突数量（Collision Count）：冲突数量是指哈希桶中发生碰撞的键值对数量。当冲突数量超过一定阈值时，通常表示哈希冲突比较严重，也可能会影响性能。这时就需要进行扩容，以减少冲突。
	    
	     
	    
	    典型的冲突数量阈值为哈希桶数量的一半，即当冲突数量超过哈希桶数量的一半时，就会触发扩容操作。
	    
	
	当装载因子或冲突数量达到扩容条件时，字典就会执行扩容操作。扩容操作涉及以下步骤：
	
	1. 创建一个新的更大尺寸的哈希桶数组。
	    
	2. 将现有的键值对重新分配到新的哈希桶中，根据键的哈希值重新计算键在新哈希桶中的位置。
	    
	3. 更新字典的哈希桶数组和相应的元素数量等参数。
	    
```c#
	//当我们尝试添加一个键值对的时候,字典都做了什么呢
	dic.Add("a",111);//这里添加了一个键为字符串,值为整数的键值对
	//首先我们通过哈希函数来获取键的哈希值,把键值对的键给哈希函数,哈希函数就会返回给你一个哈希值.这里引用类型传入的是地址
	 hashCode(a)=11;//假设这里a的哈希值是11
	//然后我们用哈希值%(模)哈希桶的长度.这是为了确保哈希值不会超出哈希桶的长度.
	//这里的哈希桶和键值对数组在扩容时会扩容成比当前容量大的最小质数(只拥有1为因数的数)
	//上面是扩容时机了,这里哈希桶的大小我先写成7
	11%7==4;//这里的结果是当前哈希值在哈希桶内的下标
	//在哈希桶中存储:当前键值对存储在键值对数组内的下标.这里的下标就是图片中count来记录的,当然如果有删除时,也会记录在freeCount中,这样在下次添加时会优先从被删除过的位置添加.
	buckets[4]=0;//这里的0就是新加入的键值对存储的下标.而4是通过结算得到的哈希桶的下标	
 
 
```
然后是哈希冲突,哈希冲突是字典中无法避免的情况(出现哈希值相同的情况就叫哈希冲突)
![[Pasted image 20240508205935.png]]
上面是哈希冲突的一种解决方法,拉链法 c#字典底层用的就是这个
我们可以看到next 和 哈希桶内的数据默认都i是-1,-1就代表这个位置是空的
如图我们可以看到key a 与 key e 发生了哈希冲突.在键e 尝试往哈希桶内的位置添加下标时,发现这里哈希桶的值不是-1,这意味着这个位置已经被别人占了.这个时候我们在Entry 中定义的next就派上了用场.这个时候我们需要把后添加进来的Key e 的next字段赋值为上一个占领这个坑的键值对的下标.
这样就解决了一次哈希冲突.当同一个位置发生多起哈希冲突时也是用这种方法一层一层找下去的.
图片右边的代码就是我们在查找键数据时的代码逻辑.
可以看到我们对找到的Entry结构体的键与我要查找的键进行了一下对比,来判断他们俩是否相同,如果键匹配不上的话就会继续用找到的键值对的next作为下标继续查找,直到找到为止.

上面介绍的字典底层逻辑不过是沧海一粟

视频出处
【C#语法之字典Dictioanry，及其底层实现逻辑讲解。】 https://www.bilibili.com/video/BV1fC4y1y7L2/?share_source=copy_web&vd_source=55c3df9d319d9b7130c0272de44eb387

字典底层细致实现
[C# 之Dictionary（字典）底层源码解析 - 赵不灰 - 博客园 (cnblogs.com)](https://www.cnblogs.com/zhaolaosan/p/16244067.html)


字典底层使用两个数组和散列函数的设计目的之一是为了实现较低的时间复杂度。

通过使用散列函数，字典可以将键转换为唯一的哈希码，并将键值对存储在对应的桶中。因此，当进行查找、插入或删除操作时，可以通过散列函数计算键的哈希码，并直接定位到对应的桶，而不需要遍历整个数据结构。

对于散列函数设计得较好且哈希冲突较少的情况，字典的插入、查找和删除操作的平均时间复杂度可以达到常数级别（O(1)），即与字典中存储的键值对数量无关。这是因为通过哈希码直接访问对应桶的操作具有固定的时间复杂度。

因此，字典底层使用两个数组和散列函数的设计目的是为了提供高效的字典操作，确保在大多数情况下，这些操作的时间复杂度保持较低且稳定。这使得字典成为处理大量键值对的数据结构中的常见选择。

但在极少数情况下，字典操作的时间复杂度可能会变为 O(n)，其中 n 表示字典中存储的键值对数量。这种情况通常出现在发生大量哈希冲突时，导致所有键值对都被存储在同一个桶中形成一个长链表。

当哈希冲突发生时，键值对会被存储在同一个桶的链表中。如果哈希冲突较为频繁或者哈希函数设计不合理，可能会导致大量的键值对被存储在同一个桶中，形成一个较长的链表。在这种情况下，进行查找、插入或删除特定键值对的操作时，需要遍历整个链表来找到目标键值对，导致操作的时间复杂度变为 O(n)，其中 n 是链表的长度。

这种情况下的时间复杂度退化是因为链表的遍历操作需要线性时间，与链表的长度成正比。而通常情况下，字典的操作时间复杂度是常数级别的，与存储的键值对数量无关。

为了避免时间复杂度的退化，需要合理设计散列函数，以减少哈希冲突的发生。另外，可以考虑使用更高效的解决哈希冲突的方法，如开放寻址法（Open Addressing）等，以减少链表的长度，提高字典操作的性能。

开放寻址法（Open Addressing）是一种解决哈希冲突的方法，它将所有的键值对直接存储在哈希表中，而不是通过链表等数据结构进行存储。在开放寻址法中，当发生哈希冲突时，会通过一定的探测序列在哈希表中寻找下一个可用的位置来存储冲突的键值对。

下面是开放寻址法的基本思想和步骤：

1. 哈希表由一个固定大小的数组构成，每个数组元素（通常称为哈希桶或槽）可以存储一个键值对。
    
2. 当要插入一个键值对时，首先计算键的哈希值。
    
3. 将哈希值与哈希表的大小进行取模运算，得到初始位置的下标。
    
4. 如果初始位置为空，即该位置没有被占用，直接将键值对存储在该位置。
    
5. 如果初始位置不为空，表示发生了哈希冲突，根据一定的探测序列继续在哈希表中寻找下一个位置。
    
6. 使用探测序列在哈希表中逐个查找下一个位置，直到找到一个空位置或者遍历整个哈希表。
    
7. 如果找到空位置，就将键值对存储在该位置。
    
8. 如果遍历整个哈希表仍未找到空位置，表示哈希表已满，无法插入新的键值对。
    

在查找和删除操作中，使用相同的步骤来找到目标键的位置，并进行相应的操作。

需要注意的是，开放寻址法要求哈希表的大小是固定的，并且要足够大以容纳所有的键值对。同时，合适的探测序列的选择对于开放寻址法的性能和哈希冲突的处理效果具有重要影响。

常见的开放寻址法的探测序列包括线性探测（Linear Probing）、二次探测（Quadratic Probing）、双重哈希（Double Hashing）等。每种探测序列有不同的特点和性能表现，具体的选择取决于应用需求和哈希表的特点。

总结起来，开放寻址法是一种在哈希表中直接存储键值对，并通过探测序列解决哈希冲突的方法。它提供了较好的缓存性能，但在高装载因子和频繁哈希冲突的情况下可能性能下降，并且需要选择合适的探测序列来优化性能。
下面是线性探测、二次探测和双重哈希的具体实现方法：

1. 线性探测（Linear Probing）：
    
    - 插入操作：如果哈希表的初始位置已经被占用，线性探测将逐个向后查找下一个位置，直到找到一个空位置或者遍历整个哈希表。具体的步长可以是固定的1，即逐个向后查找位置，也可根据实际情况进行调整。
    - 查找操作：根据哈希值计算初始位置，如果该位置的键与目标键相等，即找到目标键；否则，按照相同的步长逐个向后查找下一个位置，直到找到目标键或者遍历整个哈希表。
2. 二次探测（Quadratic Probing）：
    
    - 插入操作：如果哈希表的初始位置已经被占用，二次探测将按照平方数的步长逐个向后查找下一个位置。例如，第一次探测步长为1，第二次探测步长为4，第三次探测步长为9，以此类推。具体的步长可以根据实际情况进行调整。
    - 查找操作：根据哈希值计算初始位置，如果该位置的键与目标键相等，即找到目标键；否则，按照平方数的步长逐个向后查找下一个位置，直到找到目标键或者遍历整个哈希表。
3. 双重哈希（Double Hashing）：
    
    - 插入操作：使用第二个哈希函数计算出的值作为步长，在哈希表中逐个向后查找下一个位置。具体的步长可以是固定的，也可根据实际情况进行调整。
    - 查找操作：根据哈希值计算初始位置，如果该位置的键与目标键相等，即找到目标键；否则，按照第二个哈希函数计算出的步长逐个向后查找下一个位置，直到找到目标键或者遍历整个哈希表。

需要注意的是，在实现这些探测方法时，要注意处理哈希表边界的情况，确保不会越界。

总的来说，线性探测、二次探测和双重哈希是常见的开放寻址法的探测序列。它们提供了不同的方式来确定下一个探测位置，以解决哈希冲突并在哈希表中存储和查找键值对。具体选择哪种探测方法取决于应用需求和性能要求。