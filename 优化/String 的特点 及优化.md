#字符串的特点
1. **字符串是不可变的**：一旦字符串被创建，其内容就不能更改。这是因为字符串是由字符数组（`char[]`）组成的，只读集合。任何对字符串的“修改”操作实际上都会创建一个新的字符串对象(字符串的GC问题)

#stringBuilder优化
相比较之下StringBuilder 的开销会比单纯用String的开销会小很多
StringBuilder 在什么情况下会产生GC呢
(1) 实例化StringBuilder时 
(2) StringBuilder 容量不够扩容时,这个时候会创建一个大小为原来两倍的空间,并且把数据复制过去.(3)拿取StringBuilder 的时候也就是StringBuilder.ToString 的时候.以及操作StringBuilder 时进行装箱和toString 的时候
<font color=red> StringBuilder的默认大小是16 个字节,可以在实例化StringBuilder 时自定义大小.同样因为对StringBuilder 修改不会创建新的字符串所以追加的字符串以及追加后的字符串都不会出现在字符串中</font>
 
 相比较直接操作String 这样的GC已经小很多了,下面是StringBuiulder的一些特点
 1. 字符数组缓冲区：`StringBuilder` 内部维护了一个字符数组作为字符串数据的缓冲区。这个字符数组的长度会根据需要自动扩展，以容纳新的字符数据。
    
2. 初始容量和自动扩展：`StringBuilder` 在创建时可以指定一个初始容量，用于预估字符串的长度。如果字符串的长度超过了初始容量，`StringBuilder` 会自动扩展缓冲区的大小，以容纳更多的字符数据。扩展的算法通常是按照一定的策略进行，例如每次扩展时将缓冲区大小翻倍。
    
3. 连续的字符存储：`StringBuilder` 在进行字符串拼接、插入、删除等操作时，并不会创建新的字符串对象。相反，它会直接在字符数组缓冲区中进行修改和操作。这使得 `StringBuilder` 可以避免频繁创建和销毁字符串对象的开销。
    
4. 字符串长度和位置管理：`StringBuilder` 使用一个变量来跟踪当前字符串的长度，以及下一个字符要插入的位置。这样可以快速定位到缓冲区中的正确位置进行字符操作。
    

#StringBuilder运用字符串池的时机
1. 使用 `StringBuilder` 的 `Append` 方法拼接字符串时，如果拼接的字符串是字符串常量（如字面量或已经在代码中定义的字符串），那么 `StringBuilder` 会尝试直接引用字符串池中的已存在的字符串对象
2.  使用 `StringBuilder` 的 `ToString` 方法将 `StringBuilder` 对象转换为字符串时，如果 `StringBuilder` 内部的字符数据与字符串1池中已存在的字符串内容相同，`StringBuilder` 会直接返回字符串池中的字符串对象。


string类型进行比较
string.ReferenceEquals();//比较地址
string.Equals();比较值

#字符串驻留池
你可以将字符串驻留池视为一个字典的数据结构，其中键是字符串的内容，而值是字符串对象在堆中的地址或引用。

驻留池维护了一个映射关系，它允许以字符串的内容作为键来查找对应的字符串对象。当你创建一个字符串对象时，运行时会检查驻留池中是否已经存在具有相同内容的字符串。如果存在，运行时会返回驻留池中字符串对象的引用；如果不存在，运行时会在堆上分配一个新的字符串对象，并将其添加到驻留池中，以便以后可以重复使用。

#字符串常量池与字符串驻留池
字符串常量会在编译时被存储到字符串常量池中,一般指的是字符串字面量<font color=red>"a"+"a"这样相加的会对其进行折叠让其等价与"aa"从而进入常量池</font>,如果拥有相同的字符串那么只会开辟一块空间并且访问同一个地址.字符串常量池在进入运行时后会把常量池内的数据同步给驻留池.操作驻留池的API string.Intern("字符串");如果驻留池中有相同的字符串就会直接返回地址,否则创建新的字符串并存储在驻留池中.值得注意的是如果我们使用new 创建的字符串那么就会直接在堆中开辟空间用来存储新创建的字符串.


